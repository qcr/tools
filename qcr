#!/usr/bin/env bash
#
# This is the main script where all of the "work" happens. It can be used
# directly in a normal workflow (e.g. symlink into ~/bin, or add to $PATH,
# etc). 
# 
# This is also invoked by the `qcr_standalone` wrapping script.
#
# Author: B. Talbot
# Version: 0.7.0

set -euo pipefail

#################
### VARIABLES ###
#################


# The name of this script, and the directory where it is located
SCRIPT_NAME="$(basename $(readlink -f $0))"
SCRIPT_DIR="$(dirname $(readlink -f $0))"


#################
### FUNCTIONS ###
#################

print_usage() {
  printf "The QCR Script - access to all our shared tools

Usage:
  qcr [-c|--use-cached] [-h|--help] [-l|--list] <tools> <sub-command> <arguments>

Arguments:
  -c|--use-cached   ignore checking for updates, use the cached version of qcr and tools (not yet implemented)
  -h|--help         show this help menu
  -l|--list         list available commands

Examples:
  Print the list of available tools: qcr -l
  Print the services tool help menu: qcr services -h


Further Details:

    Please open an issue in the QCR tools repository for questions, support, or
    to report bugs: https://github.com/qcr/tools/issues
  
"

  exit 0
}

list_tools(){
  scripts_dir=${SCRIPT_DIR}/scripts/
  cmds="$(find "$scripts_dir" -maxdepth 1 -executable -type f)"

  printf "Available Tools:\n"
  for cmd in ${cmds[@]}; do
    printf "  > $(basename $cmd)\n"
  done

  # TODO - remove once systems_config has moved elsewhere
  printf "  > system_configs\n"

  exit 0
}


############
### MAIN ###
############

# Source common
source ${SCRIPT_DIR}/common


# Bail if git isn't found
git_command_exists

# Check if latest version of qcr repo, pass with empty name 
# so prints 'qcr update' and not 'qcr update qcr'
check_cloned_repo_is_latest ${SCRIPT_DIR} ""


# Split args into what is parsed here, and what goes to a subcommand
sub_index=$(printf '%s\n' "$@" | grep -n '^[a-zA-Z]' | head -n 1 | cut -f1 -d: || echo "$(($#+1))")
main_args=( "${@:1:$((sub_index-1))}")
sub=( "${@:$sub_index}" )
 

# Process main arguments using getopt command
PARSED_ARGS=$(getopt -a -n ${SCRIPT_NAME} -o chl --long use-cached,help,long -- "${main_args[@]}")
USE_CACHED=false
eval set -- "${PARSED_ARGS}"
while true; do
  case "$1" in 
    -h|--help) 
      print_usage ;;
    -l|--list)
      list_tools ;;
    -c|--use-cached)
      USE_CACHED=true; shift ;;
    # -- indicates end of arguments, break while loop
    --) shift; break ;;
    # invalid option was passed, print usage
    *)
      printf "${ERROR} Unrecognized option '$1'\n" 
      print_usage 
      exit 1 ;;    
  esac
done


# Divert to selected command
scripts_dir="${SCRIPT_DIR}/scripts"
cmds="$(find "$scripts_dir" -executable -type f | sed "s|^$scripts_dir/||; s|/| |g; s/ \.command$//")"
cmd="$(echo "$cmds" | while read c; do \
  [[ "${sub[@]}" == "$c "* ]] || [[ "${sub[@]}" == "$c" ]] && \
    echo "$c" || true; done | \
  awk '{ print NF, $0 }' | sort -n | cut -d' ' -f 2- | tail -n 1)"

if [ -z "$cmd" ]; then
  if [ ${#sub[@]} -gt 0 ]; then
    printf "\n${ERROR}No command matched '%s'.\n\n" "$(echo "${sub[@]}")"
  fi
  printf '%s\n' \
    'Please make a call that matches one of the following available commands:'
  printf '%s\n' "${cmds[@]}" | sed 's/^/\t/' | sort
  exit 1
fi


# Execute the command
sub_cmd="$scripts_dir/$(echo "$cmd" | sed 's/ /\//g')"
[ -d "$sub_cmd" ] && sub_cmd="$sub_cmd/.command"
sub_args=( "${sub[@]:$(echo "$cmd" | wc -w)}" )
printf "${INFO}Calling '$sub_cmd'%s\n\n" \
  "$([ ${#sub_args[@]} -eq 0 ] || echo " with args '${sub_args[@]}'")"

$sub_cmd "${sub_args[@]}"
