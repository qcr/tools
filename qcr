#!/usr/bin/env bash
#
# A light wrapper for using QCR tools. This is deliberately light, so that
# users should never have to update this script once they have it, but will
# always have access to the latest tools.
#
# It is also designed to work offline, and prompt you when updates are
# available. Please see https://github.com/qcr/tools for full details on how
# things work.
#
# Author: Ben Talbot
# Version: 0.4.0

set -euo pipefail
abs_path="$(readlink -f $0)"

################################################################################
############################### Script settings ################################
################################################################################


INSTALL_DIR="/var/tmp"
REPO_DIR="${INSTALL_DIR}/qcr"
REPO_URL="https://github.com/qcr/tools"
SCRIPTS_DIR="${REPO_DIR}/scripts"

INFO='\033[0;35m[INFO] '
WARN='\033[0;33m[WARN] '
ERROR='\033[0;31m[ERROR] '
NC='\033[0m'

################################################################################
################################ Main execution ################################
################################################################################

# Install if not installed
if [ ! -d "$REPO_DIR" ]; then
  printf "${INFO}%s${NC}\n" \
    "No cached version found. Installing to '$REPO_DIR'..."
  if ! git clone "$REPO_URL" "$REPO_DIR"; then
    printf "${ERROR}%s${NC}\n" \
      "Install failed, please ensure machine has internet access."
    exit 1
  fi
fi

# Check whether installed version is the latest (flagging if there are updates
# available, or update check failed)
latest="$(git -C "$REPO_DIR" ls-remote 2>/dev/null | \
  grep HEAD | cut -f 1 || true)"
installed="$(git -C "$REPO_DIR" rev-parse HEAD)"
if [ -z "$latest" ]; then
  printf "${WARN}%s${NC}\n" \
    "Check for latest tools failed; using cached version in '$REPO_DIR'."
elif [ "$latest" != "$installed" ]; then
  printf "${WARN}%s%s\n\t\t%s${NC}\n" \
    "Old version (${installed:0:8}) found in '$REPO_DIR'. " \
    "Update to latest (${latest:0:8}) using:" \
    "qcr update"
fi

# Split args into what is parsed here, and what goes to a subcommand
sub_index=$(printf '%s\n' "$@" | grep -n '^[a-zA-Z]' | \
  head -n 1 | cut -f1 -d: || echo "0")
main_args=( "${@:0:$sub_index}")
sub_args=( "${@:$sub_index}" )
exit 0

# Process arguments, and divert to sub-scripts as appropriate
parsed=$(getopt -o h --long help -n "$(basename "$abs_path")" -- "$@")
echo "SUCCESS"
