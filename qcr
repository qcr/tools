#!/usr/bin/env bash
#
# A light wrapper for using QCR tools. This is deliberately light, so that
# users should never have to update this script once they have it, but will
# always have access to the latest tools.
#
# It is also designed to work offline, and prompt you when updates are
# available. Please see https://github.com/qcr/tools for full details on how
# things work.
#
# Author: Ben Talbot
# Version: 0.4.0

set -euo pipefail
abs_path="$(readlink -f $0)"

################################################################################
############################### Script settings ################################
################################################################################


INSTALL_DIR="/var/tmp"
REPO_DIR="${INSTALL_DIR}/qcr"
REPO_URL="https://github.com/qcr/tools"
SCRIPTS_DIR="${REPO_DIR}/scripts"

################################################################################
########################### Variables and functions ############################
################################################################################

INFO='\033[0;35m[INFO] '
WARN='\033[0;33m[WARN] '
ERROR='\033[0;31m[ERROR] '
NC='\033[0m'

usage_text="$(basename "$abs_path") -- QCR script for access to all our shared tools

USAGE:

    Run a command located in $REPO_DIR/scripts/my_command:
        $(basename "$abs_path") my_command

    Run a subcommand located in $REPO_DIR/scripts/my_commands/subcommand
        $(basename "$abs_path") my_commands subcommand

    Print this help text:
        $(basename "$abs_path") --help

OPTION DETAILS:

    -h, --help
            Show this help menu.


FURTHER DETAILS:

    Please open an issue in the QCR tools repository for questions, support, or
    to report bugs:
        https://github.com/qcr/tools/issues
"

################################################################################
################################ Main execution ################################
################################################################################

# Bail if git isn't found
command -v git >& /dev/null || {
  printf "${ERROR}%s${NC}\n" "Command 'git' was not found, please install"
  exit 1
}

# Install if not installed
if [ ! -d "$REPO_DIR" ]; then
  printf "${INFO}%s${NC}\n" \
    "No cached version found. Installing to '$REPO_DIR'..."
  if ! git clone "$REPO_URL" "$REPO_DIR"; then
    printf "${ERROR}%s${NC}\n" \
      "Install failed, please ensure machine has internet access."
    exit 1
  fi
fi

# Check whether installed version is the latest (flagging if there are updates
# available, or update check failed)
latest="$(git -C "$REPO_DIR" ls-remote 2>/dev/null | \
  grep HEAD | cut -f 1 || true)"
installed="$(git -C "$REPO_DIR" rev-parse HEAD)"
if [ -z "$latest" ]; then
  printf "${WARN}%s${NC}\n" \
    "Check for latest tools failed; using cached version in '$REPO_DIR'."
elif [ "$latest" != "$installed" ]; then
  printf "${WARN}%s%s\n\t%s${NC}\n" \
    "Old version (${installed:0:8}) found in '$REPO_DIR'. " \
    "Update to latest (${latest:0:8}) using:" \
    "qcr update"
fi

# Split args into what is parsed here, and what goes to a subcommand
sub_index=$(printf '%s\n' "$@" | grep -n '^[a-zA-Z]' | \
  head -n 1 | cut -f1 -d: || echo "$(($#+1))")
main_args=( "${@:1:$((sub_index-1))}")
sub=( "${@:$sub_index}" )

# Process main command arguments
parsed=$(getopt -o h --long help -n "$(basename "$abs_path")" \
  -- "${main_args[@]}")
eval set -- "$parsed"
while true; do
  case "$1" in
    -h|--help)
      echo "$usage_text" ; exit 0 ;;
    --)
      shift ; break ;;
    *)
      # We'll never get here
      printf "${ERROR}%s\n${NC}" \
        "Option '$1' to '$(basename "$abs_path")' is unknown" ; shift; exit 1 ;;
  esac
done

# Divert to selected command
# TODO add support for sub-commands
cmds="$(find "$SCRIPTS_DIR" -executable -type f | \
  sed "s|^$SCRIPTS_DIR/||; s|/| |g")"
cmd="$(echo "$cmds" | while read c; do \
  [[ "${sub[@]}" == "$c "* ]] || [[ "${sub[@]}" == "$c" ]] && \
    echo "$c" || true; done | \
  awk '{ print NF, $0 }' | sort -n | cut -d' ' -f 2-)"

if [ -z "$cmd" ]; then
  if [ ${#sub[@]} -gt 0 ]; then
    printf "\n${ERROR}No command matched '${sub[@]}'.${NC}\n\n"
  fi
  printf '%s\n' \
    'Please make a call that matches one of the following available commands'
  printf '%s\n' "${cmds[@]}" | sed 's/^/\t/'
  exit 1
fi

# Execute the command
# TODO add support for sub-commands
sub_cmd="$SCRIPTS_DIR/$(echo "$cmd" | sed 's/ /\//g')"
sub_args=( "${sub[@]:$(echo "$cmd" | wc -w)}" )
printf "${INFO}Calling '$sub_cmd' with args '%s'${NC}\n" \
  "$(echo "${sub_args[@]}")"
$sub_cmd "${sub_args[@]}"
